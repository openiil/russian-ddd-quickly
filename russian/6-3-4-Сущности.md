### Сущности  

Есть объекты, у которых есть постоянная идентичность. Их свойства могут меняться, но мы всё равно считаем, что это один и тот же объект на протяжении жизни системы и иногда даже за её пределами. Такие объекты называют сущностями (Entities).

Языки ООП хранят экземпляры объектов в памяти и связывают с каждым объектом ссылку или адрес в памяти. В конкретный момент времени такая ссылка уникальна для данного объекта, но нет никаких гарантий, что она сохранится надолго. Скорее наоборот. Объекты постоянно “покидают” память и возвращаются: их сериализуют, отправляют по сети и воссоздают на другой стороне, либо уничтожают. Поэтому ссылка, которая выступает идентификатором лишь внутри текущего выполнения программы это не та идентичность, о которой идёт речь, когда мы говорим о сущностях. Если есть класс, который хранит данные о погоде, например температуру, вполне можно создать два разных экземпляра этого класса с одним и тем же значением. Такие объекты полностью равны по данным и взаимозаменяемы, хотя ссылки у них разные. Это не сущности.

Если бы мы реализовывали понятие человека в программной системе, мы, скорее всего, создали бы класс Person с набором атрибутов: имя, дата рождения, место рождения и т.д. Но является ли какой-то из этих атрибутов идентичностью человека? Имя не может быть идентичностью, потому что людей с одним и тем же именем может быть много. Мы не смогли бы различить двух людей с одинаковым именем, если бы учитывали только его. Дату рождения тоже нельзя использовать: в один и тот же день рождается множество людей. То же относится и к месту рождения. Объект должен быть отличим от других объектов, даже если у них совпадают атрибуты. Ошибка в идентификации может привести к порче данных.

Пример банковской системы: каждый счёт имеет свой номер. Счёт можно точно идентифицировать по номеру. Этот номер остаётся неизменным на протяжении всей жизни системы и обеспечивает непрерывность. Номер может существовать как объект в памяти, быть уничтожен и сохранён в базе данных, а также архивирован при закрытии счёта, но всё равно остаётся где‑то, пока есть интерес к его хранению. Не важно, в каком виде он представлен — номер остаётся тем же.  

Следовательно, реализация сущности в программном обеспечении подразумевает создание идентичности. Для человека это может быть комбинация атрибутов: имя, дата рождения, место рождения, имена родителей, текущий адрес. В США в качестве идентичности часто используют номер социального страхования. Для банковского счёта достаточно номера счёта. Обычно идентичность представляет собой либо отдельный атрибут объекта, либо комбинацию атрибутов, либо специально созданный атрибут, сохраняющий и выражающий идентичность, а ингода даже поведение. Важно, чтобы система легко различала два объекта с разной идентичностью и считала одним и тем же объектом два объекта с одинаковой идентичностью. Если это условие не выполнено, система может быть повреждена.

Есть разные способы создать уникальную идентичность для каждого объекта. Идентификатор (ID) может автоматически генерироваться отдельным модулем и использоваться внутри системы, не будучи видимым пользователю. Он может быть первичным ключом в таблице базы данных, уникальность которого гарантируется на уровне БД. Когда объект извлекают из базы, его ID тоже извлекают и по нему в памяти воссоздают тот же объект. Идентификатор может задаваться и пользователем, как это бывает с кодами аэропортов. У каждого аэропорта есть уникальный строковый код, международно признанный и используемый туристическими агентствами по всему миру для идентификации аэропортов в расписаниях. Ещё один вариант — формировать ID из атрибутов объекта. А если этих атрибутов недостаточно для уникальности, можно добавить дополнительный атрибут, который поможет однозначно идентифицировать нужный объект.

Когда объект различается по своей идентичности, а не по атрибутам, делайте это первичным в определении модели. Держите определение класса простым и сосредоточенным на непрерывности жизненного цикла и идентичности. Определите способ различения каждого объекта независимо от его формы или истории. Будьте внимательны к требованиям, требующим сопоставления объектов по атрибутам. Определите операцию, гарантированно выдающую уникальный результат для каждого объекта, возможно, привязывая уникальный символ. Этот способ идентификации может приходить извне или быть произвольным идентификатором, созданным системой, но он должен соответствовать различиям идентичности в модели. Модель должна определять, что значит быть тем же самым.  

Когда объект различают по идентичности, а не по набору атрибутов, сделайте это основой его определения в модели. Держите определение класса простым и сосредоточенным на непрерывности жизненного цикла и идентичности. Заранее определите способ отличать каждый объект независимо от его текущей формы или истории. При этом будьте внимательны к требованиям, где нужно сопоставлять объекты по атрибутам. Определите способ, который гарантирует уникальную идентификацию каждого объекта, например присваивая ему отдельный уникальный идентификатор. Такой способ идентификации может приходить извне или быть произвольным идентификатором, создаваемым системой для собственных нужд, но он должен соответствовать тем различиям идентичности, которые заложены в модели. Модель должна определять, что значит быть “тем же самым”.

Сущности это важные объекты доменной модели, их следует учитывать с самого начала процесса моделирования. Также важно определить, должен ли конкретный объект быть сущностью или нет — это будет обсуждаться в следующем паттерне.
